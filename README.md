# ToolForge AI: Multi-Agent System for Tool Development

**ToolForge AI** — это прототип мультиагентной системы (MAS), построенный на базе **LangGraph**. Система автоматизирует процесс создания программных инструментов для LLM-агентов: от концептуального проектирования до генерации и сохранения готового Python-кода.

---

## Основная идея

Проект реализует паттерн разделения ответственности (Separation of Concerns). Вместо одного монолитного агента, задача проходит через специализированные узлы графа:

1.  **Manager (Диспетчер)**: Анализирует запрос и выбирает маршрут (проектирование, кодинг, анализ или просто чат).
2.  **Architect (Архитектор)**: Формирует интерфейс функции (сигнатуру, аргументы, докстринг), не отвлекаясь на детали реализации.
3.  **Developer (Разработчик)**: Пишет рабочий код по спецификации и физически сохраняет его в файловую систему.
4.  **Analyst (Аналитик)**: Сканирует существующие файлы и объясняет их работу пользователю.


---

## Структура файлов

* `main.py` — интерактивный CLI-интерфейс с потоковым выводом действий агентов.
* `graph.py` — описание архитектуры графа состояний и логики переходов.
* `agents.py` — реализация логики каждого агента и инициализация LLM.
* `tools.py` — набор инструментов для работы с файловой системой (`write`, `read`, `list`).
* `created_tools/` — директория-"песочница", где хранятся созданные агентами скрипты.

---

## Установка и запуск

Проект оптимизирован для использования с пакетным менеджером [uv](https://docs.astral.sh/uv/).

### 1. Подготовка окружения
Убедитесь, что у вас установлен `uv`. Клонируйте проект и создайте файл `.env` в корневой директории:

```ini
LITELLM_BASE_URL=your url
MODEL_NAME=qwen3-32b
LITELLM_API_KEY=your-api-key
TOOLS_DIR="your directory for generated tools"
```

### 2.Установка зависимостей
Благодаря uv.lock и pyproject.toml, установка происходит одной командой
```bash
uv sync
```

### 3. Запуск
Запустите демонстрацию в интерактивном режиме:
```bash
uv run main.py
```

## Концептуальный разбор

### 1. Роли и ответственности агентов
Система построена на принципе четкого разделения обязанностей (Separation of Concerns):

**Manager (Router)**: Центральный узел принятия решений. Анализирует интенты пользователя и осуществляет маршрутизацию (handoff) к профильным узлам. Не генерирует контент, а управляет логикой графа.

**Architect (Planner/Designer)**: Отвечает за логическое проектирование. Его задача — создать абстрактную спецификацию (интерфейс) без реализации, что минимизирует галлюцинации в коде.

**Developer (Executor/Coder)**: Специализированный агент-программист. Преобразует спецификацию Архитектора в исполняемый Python-код и взаимодействует с файловой системой.

**Analyst (RAG/Code Reviewer)**: Работает с контекстом существующих данных. Исследует директорию инструментов, читает код и интерпретирует его для пользователя.

### 2. Паттерны МАС
В данной системе реализована комбинация нескольких паттернов:

**Router (Маршрутизатор)**: Реализован в manager_node, который на основе анализа текста перенаправляет состояние в нужную ветку.

**Specialized Agents (Специализированные агенты)**: Каждый узел (architect, developer, analyst) имеет уникальный системный промпт и набор инструментов, оптимизированный под узкую задачу.

**Handoff (Передача управления)**: Явно выражен в цепочке Architect -> Developer. Архитектор передает "эстафету" вместе с подготовленной спецификацией в поле tool_spec.

### 3. Диаграмма потока управления (Mermaid)
Фрагмент кода

graph TD
    Start((START)) --> Manager{Manager Node}
    
    Manager -- "DESIGN" --> Architect[Architect Node]
    Manager -- "IMPLEMENT" --> Architect
    Manager -- "ANALYST" --> Analyst[Analyst Node]
    Manager -- "CHAT" --> End((END))
    
    Architect -- "is_coding_task=True" --> Developer[Developer Node]
    Architect -- "is_coding_task=False" --> End
    
    Developer --> End
    Analyst --> End


### 4. Tool Calling и управление памятью

#### Tool Calling (Вызов инструментов):

**Developer**: Использует инструмент write_to_file. Это критический этап handoff между ИИ-логикой и физической средой (сохранение .py файлов).

**Analyst**: Использует list_files и read_file. Это позволяет агенту "видеть" внешнюю среду и работать с актуальным состоянием папки tools/.

#### Управление памятью:

**Что хранится**: В объекте AgentState хранится полная история сообщений (messages) и промежуточные данные (tool_spec, is_coding_task).

**Где хранится**: Память является эфемерной и живет в рамках одной сессии в StateGraph. Переменная messages использует operator.add, что позволяет автоматически накапливать историю (Short-term memory).

**Влияние на шаги**: Благодаря накоплению истории в messages, агент Аналитик может объяснять код, который Разработчик создал несколько шагов назад, обеспечивая контекстную связность диалога.

### Подробный отчет по запросам с полным логом запросов в папке evaluation_and_report
