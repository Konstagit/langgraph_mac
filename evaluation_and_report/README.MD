## Задание 3. Эксперименты и анализ запросов

Ниже приведён разбор пяти запросов, выполненных в **ToolForge AI Terminal**.

---

### Запрос 1. Концептуальный вопрос (МАС/агенты)
**Текст запроса:**  
> Объясни простыми словами, чем отличается паттерн 'Supervisor' от последовательного воркфлоу в мультиагентных системах. Когда какой лучше использовать?

**Активация агентов (порядок):**  
`Manager → Analyst`

**Инструменты и память:**  
- Инструменты не вызывались  
- Использовалась внутренняя «база знаний» LLM (генерация ответа из модели)

Полный ответ доступен в fulllog.txt. Мой комментарий:
Ответ полезный и структурированный. Analyst удачно опёрся на аналогии (конвейер vs менеджер) и объяснил, когда какой подход применять. Маршрутизация сработала корректно.

---

### Запрос 2. Проектирование/архитектура
**Текст запроса:**  
> Я хочу создать инструмент для поиска дубликатов файлов в папке. Спроектируй структуру функции: какие аргументы ей нужны, что она должна возвращать и как обработать ошибки, если папка пуста?

**Активация агентов (порядок):**  
`Manager → Architect`

**Инструменты и память:**  
- Инструменты не вызывались  
- Память не обновлялась явно, ответ построен как проектирование интерфейса и поведения функции

Полный ответ доступен в fulllog.txt. Мой комментарий: 
Ответ сильный: хорошо описаны аргументы, формат возвращаемых данных, сценарии ошибок, дан псевдокод. Но это именно дизайн, а не реализация. Код в файл не сохранялся, потому что не было явной команды «реализуй/сохрани».

---

### Запрос 3. Реализация/программирование (создание файла)
**Текст запроса:**  
> Напиши и сохрани в файл password_gen.py инструмент, который генерирует случайный пароль заданной длины с использованием спецсимволов. Используй декоратор @tool.

**Активация агентов (порядок):**  
`Manager → Architect → Developer (system output)`

**Инструменты и память:**  
- Architect сгенерировал код
- Сработал инструмент сохранения файла (вывод Developer Output)
- Память использовалась краткосрочно: передача сгенерированного кода в инструмент записи файла

Полный ответ доступен в fulllog.txt. Мой комментарий:
Код в целом рабочий. Но есть заметный промах по требованиям: пользователь просил имя файла `password_gen.py`, а система сохранила файл как `created_tools\generate_password.py`. То есть содержимое ок, но итоговый артефакт не соответствует запросу.

---

### Запрос 4. Повседневная задача (работа с состоянием системы)
**Текст запроса:**  
> Выведи список всех инструментов, которые ты уже создал для меня, и кратко опиши, что делает каждый из них.

**Активация агентов (порядок):**  
`Manager → Analyst`

**Инструменты и память:**  
- Вызван инструмент: `list_files args: {}`
- Analyst использовал результат list_files + контекст прошлых диалогов

**Комментарий:**  
Ответ частично «галлюцинирует». Агент указал `find_duplicates.py` как уже созданный инструмент, хотя во 2-м запросе был только дизайн, без сохранения файла. Это ошибка смешения: «мы обсуждали» стало для агента «это точно существует на диске».

---

### Запрос 5. Модификация кода (обновление файла)
**Текст запроса:**  
> Прочитай код в файле password_gen.py. Добавь в него проверку, чтобы длина пароля не могла быть меньше 8 символов, и обнови файл.

**Активация агентов (порядок):**  
`Manager → Architect → Developer (Output)`

**Инструменты и память:**  
- Логически должна была быть операция чтения файла (но в логе не отображена явно)
- Использован инструмент перезаписи/сохранения обновлённого файла
- Память/контекст применялись для восстановления цели правки (минимальная длина 8)

Полный ответ доступен в fulllog.txt. Мой комментарий: 
Проверка добавлена, требование выполнено. Но реализация при этом переписана почти «с нуля»: изменились импорты, стиль и язык комментариев/docstring. Это похоже не на аккуратный patch, а на полную регенерацию кода, что может быть нежелательно в реальных проектах.

---

## Итоговая оценка системы (неформальные критерии)

| Критерий | Оценка | Анализ |
|---|---:|---|
| Маршрутизация (routing) | Отлично | Manager корректно отличал «объясни» (Analyst) от «спроектируй/напиши» (Architect). |
| Использование инструментов | Хорошо | Вызовы сохранения и list_files уместные и по делу. |
| Следование инструкциям пользователя | Средне | В запросе 3 проигнорировано требование по имени файла. |
| Управление памятью / состоянием | {Хорошо} | При экзотичных сценариях могут появляться ложные воспоминания: обсуждённый, но не созданный файл был выдан как существующий. |
| Качество редактирования (patch vs rewrite) | Хорошо | В запросе 5 правка выполнена корректно, однако произошла полная перезапись. |


## Задание 4. Рефлексия

### Что сработало хорошо
- **Ролевая модель**: разделение на Manager / Analyst / Architect оказалось понятным и полезным. Ответы были ожидаемыми по стилю и назначению.
- **Handoff**: передача управления от Manager к профильному агенту происходит быстро и прозрачно.
- **Генерация кода**: Architect выдаёт синтаксически корректный Python и в целом соблюдает требования к структуре инструмента (включая декоратор `@tool`).

### Где система ошибалась или вела себя странно
- **Галлюцинации файловой системы**: в запросе 4 агент назвал файл созданным, хотя он не сохранялся. Причина: смешение «контекста разговора» и «фактического состояния системы».
- **Игнорирование явных параметров запроса**: в запросе 3 пользователь задал имя файла `password_gen.py`, но система сохранила немного по-другому.
- **Полная перезапись вместо точечного редактирования**: в запросе 5 результат формально верный, но слишком «ломает» исходник (стиль, импорты, язык).

### Как развивать систему дальше (если бы было больше времени)
- **Добавить узел Reviewer (агент-ревьюер)**: перед выполнением tool-call проверять, что результат соответствует запросу (например, имя файла, формат, ограничения).
- **Разделить память по типам**:
  - Conversation Memory: что обсуждали
  - System State Memory: что реально создано/существует (файлы, артефакты, результаты tool-calls)
- **Инструменты для patch-редактирования**: вместо перезаписи файла целиком добавить режим «внеси минимальную правку», чтобы сохранять стиль и структуру кода.
- **Правило “trust tools over memory”**: если речь про список файлов или состояние системы, опираться только на инструменты (list/read), а не на «воспоминания» агента.
